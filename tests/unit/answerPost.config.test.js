const assert = require("node:assert/strict");
const {describe, test, beforeEach, afterEach} = require("node:test");
const path = require("node:path");
const {EventEmitter} = require("node:events");
const ModuleLib = require("module");

// Ensure shims resolve like other tests
global.process = global.process || {};
const shimDir = path.resolve(__dirname, "../shims");
process.env.NODE_PATH = shimDir + (process.env.NODE_PATH ? path.delimiter + process.env.NODE_PATH : "");
if (typeof ModuleLib._initPaths === "function") ModuleLib._initPaths();

const helperFactory = require("../../node_helper.js");

const originalLoad = ModuleLib._load;
const originalResolveFilename = ModuleLib._resolveFilename;
const moduleOverrides = new Map();

function setModuleValue (filePath, value) {
  moduleOverrides.set(path.resolve(filePath), {type: "value", value});
}

function setModuleError (filePath, error) {
  moduleOverrides.set(path.resolve(filePath), {type: "error", error});
}

function freshHelper () {
  const helper = Object.assign({}, helperFactory);
  helper.__responses = [];
  helper.sendResponse = function (_res, error, payload) {
    this.__responses.push({error, payload});
    return !error;
  };
  helper.removeDefaultValues = (config) => config;
  helper.thisConfig = {};
  helper.configOnHd = {};
  helper.configData = {moduleData: []};
  return helper;
}

class FakeReadStream extends EventEmitter {
  pipe (dest) {
    this.dest = dest;
    return dest;
  }
}

describe("answerPost config persistence", () => {
  const originalFs = {};
  const fs = require("node:fs");

  beforeEach(() => {
    ["statSync", "createReadStream", "createWriteStream", "writeFile"].forEach((key) => {
      originalFs[key] = fs[key];
    });
    ModuleLib._load = function (request, parent, isMain) {
      const resolved = path.isAbsolute(request)
        ? path.resolve(request)
        : originalResolveFilename.call(this, request, parent, isMain);
      const normalized = path.resolve(resolved);
      if (moduleOverrides.has(normalized)) {
        const entry = moduleOverrides.get(normalized);
        if (entry.type === "error") {
          throw entry.error;
        }
        return entry.value;
      }
      return originalLoad.call(this, request, parent, isMain);
    };
    moduleOverrides.clear();
  });

  afterEach(() => {
    Object.entries(originalFs).forEach(([key, value]) => {
      fs[key] = value;
    });
    moduleOverrides.forEach((_entry, filePath) => {
      delete require.cache[filePath];
    });
    moduleOverrides.clear();
    ModuleLib._load = originalLoad;
  });

  test("rotates oldest backup and writes new config", async () => {
    const helper = freshHelper();
    helper.getConfigPath = () => "/mirror/config.js";

    const mtimeBySlot = {
      4: new Date("2025-10-07T12:00:00Z"),
      3: new Date("2025-10-01T12:00:00Z"),
      2: new Date("2025-10-08T12:00:00Z"),
      1: new Date("2025-10-06T12:00:00Z")
    };
    fs.statSync = (filePath) => {
      const match = (/backup(\d)/u).exec(filePath);
      if (!match) throw Object.assign(new Error("unexpected"), {code: "ENOENT"});
      const slot = Number(match[1]);
      if (mtimeBySlot[slot]) {
        return {mtime: mtimeBySlot[slot]};
      }
      const err = new Error("missing");
      err.code = "ENOENT";
      throw err;
    };

    const readStream = new FakeReadStream();
    fs.createReadStream = (filePath) => {
      assert.equal(filePath, "/mirror/config.js");
      return readStream;
    };
    fs.createWriteStream = (filePath) => {
      assert.equal(filePath, path.resolve("config/config.js.backup3"));
      return {};
    };

    let written;
    fs.writeFile = (target, contents, callback) => {
      written = {target, contents};
      callback();
    };

    const payload = {modules: [], foo: "bar"};

    const responsePromise = new Promise((resolve) => {
      helper.sendResponse = function (_res, error, data) {
        this.__responses.push({error, data});
        resolve({error, data});
        return !error;
      };
    });

    helper.answerPost({data: "config"}, {body: payload}, {});

    readStream.emit("end");

    const {error, data} = await responsePromise;
    assert.equal(error, undefined);
    assert.equal(written.target, "/mirror/config.js");
    assert.ok(written.contents.includes("AUTO GENERATED BY REMOTE CONTROL MODULE"));
    assert.equal(data.backup, path.resolve("config/config.js.backup3"));
    assert.deepEqual(data.data, payload);
  });

  test("aborts when no backup slot available", () => {
    const helper = freshHelper();
    helper.getConfigPath = () => "/mirror/config.js";

    fs.statSync = () => {
      throw new Error("stat failed");
    };

    const responses = [];
    helper.sendResponse = function (_res, error, payload) {
      responses.push({error, payload});
      return !error;
    };

    helper.answerPost({data: "config"}, {body: {}}, {});

    assert.equal(responses.length, 1);
    assert.ok(responses[0].error instanceof Error);
    assert.match(String(responses[0].error), /Backing up config failed/);
  });

  test("propagates write errors", async () => {
    const helper = freshHelper();
    helper.getConfigPath = () => "/mirror/config.js";

    fs.statSync = () => {
      const err = new Error("missing");
      err.code = "ENOENT";
      throw err;
    };

    const readStream = new FakeReadStream();
    fs.createReadStream = () => readStream;
    fs.createWriteStream = () => ({});

    const writeError = new Error("disk full");
    fs.writeFile = (_target, _contents, callback) => {
      callback(writeError);
    };

    const responsePromise = new Promise((resolve) => {
      helper.sendResponse = function (_res, error, data) {
        resolve({error, data});
        return !error;
      };
    });

    helper.answerPost({data: "config"}, {body: {foo: "bar"}}, {});
    readStream.emit("end");

    const {error, data} = await responsePromise;
    assert.equal(error, writeError);
    assert.equal(data.query.data, "config_update");
    assert.equal(data.backup, path.resolve("config/config.js.backup1"));
  });
  test("UNDO_CONFIG restores backup when timestamp matches", () => {
    const helper = freshHelper();
    let answerArgs;
    helper.answerPost = (query, req, res) => {
      answerArgs = {query, req, res};
    };

    const targetTime = new Date("2025-10-09T10:00:00Z");
    fs.statSync = (filePath) => {
      const match = (/backup(\d)/u).exec(filePath);
      if (!match) {
        const err = new Error("missing");
        err.code = "ENOENT";
        throw err;
      }
      if (Number(match[1]) === 4) {
        return {mtime: targetTime};
      }
      const err = new Error("missing");
      err.code = "ENOENT";
      throw err;
    };

    const restoredConfig = {modules: [{module: "newsfeed"}]};
    setModuleValue("config/config.js.backup4", restoredConfig);

    helper.socketNotificationReceived("UNDO_CONFIG", targetTime.toISOString());

    assert.ok(answerArgs);
    assert.deepEqual(answerArgs.query, {data: "config"});
    assert.deepEqual(answerArgs.req.body, restoredConfig);
    assert.deepEqual(answerArgs.res, {isSocket: true});
  });

  test("UNDO_CONFIG falls back when timestamp not found", () => {
    const helper = freshHelper();
    let answerArgs;
    helper.answerGet = (query, res) => {
      answerArgs = {query, res};
    };

    helper.socketNotificationReceived("UNDO_CONFIG", new Date("2025-10-01T12:00:00Z").toISOString());

    assert.ok(answerArgs);
    assert.deepEqual(answerArgs.query, {data: "saves"});
    assert.deepEqual(answerArgs.res, {isSocket: true});
  });

  test("UNDO_CONFIG surfaces load errors", () => {
    const helper = freshHelper();

    const time = new Date("2025-10-05T09:00:00Z");
    fs.statSync = (filePath) => {
      const match = (/backup(\d)/u).exec(filePath);
      if (!match) {
        const err = new Error("missing");
        err.code = "ENOENT";
        throw err;
      }
      if (Number(match[1]) === 2) {
        return {mtime: time};
      }
      const err = new Error("missing");
      err.code = "ENOENT";
      throw err;
    };

    setModuleError("config/config.js.backup2", new Error("invalid"));

    assert.throws(() => {
      helper.socketNotificationReceived("UNDO_CONFIG", time.toISOString());
    }, /invalid/);
  });
});
